{
    "id": "python-ds-studio-test",
    "name": "Python Data Science StudioTest",
    "description": "A powerful Python environment for Data Science with Pyodide. Supports Numpy, Pandas, Matplotlib, Scikit-Learn, Scipy, Sympy, and Seaborn with Syntax Highlighting.",
    "author": "Infinition",
    "authorUrl": "https://github.com/infinition/obsidget",
    "tags": [
        "python",
        "data-science",
        "machine-learning",
        "matplotlib",
        "syntax-highlighting"
    ],
    "html": "<div class=\"ds-container\">\n  <div class=\"ds-header\">\n    <div class=\"ds-title-wrap\">\n      <div class=\"ds-logo\">\n        <svg viewBox=\"0 0 24 24\" width=\"18\" height=\"18\" stroke=\"currentColor\" stroke-width=\"2.5\" fill=\"none\"><path d=\"M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5\"></path></svg>\n      </div>\n      <div class=\"ds-title-text\">\n        <span class=\"ds-main-title\">PYTHON DATA SCIENCE</span>\n        <span class=\"ds-sub-title\">STUDIO PRO</span>\n      </div>\n    </div>\n    <div class=\"ds-top-actions\">\n      <button id=\"btn-clear\" class=\"ds-btn-tool\">\n        <svg viewBox=\"0 0 24 24\" width=\"12\" height=\"12\" stroke=\"currentColor\" stroke-width=\"2\" fill=\"none\"><polyline points=\"3 6 5 6 21 6\"></polyline><path d=\"M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2\"></path></svg>\n        Clear\n      </button>\n      <button id=\"btn-copy\" class=\"ds-btn-tool\">\n        <svg viewBox=\"0 0 24 24\" width=\"12\" height=\"12\" stroke=\"currentColor\" stroke-width=\"2\" fill=\"none\"><path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"></path><rect x=\"8\" y=\"2\" width=\"8\" height=\"4\" rx=\"1\" ry=\"1\"></rect></svg>\n        Copy\n      </button>\n    </div>\n  </div>\n\n  <div class=\"ds-editor-card\">\n    <div class=\"ds-editor-wrapper\">\n      <pre id=\"highlighting\" aria-hidden=\"true\"><code class=\"language-python\" id=\"highlighting-content\"></code></pre>\n      <textarea id=\"code-editor\" spellcheck=\"false\">import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.ensemble import IsolationForest\n\n# Aesthetic configuration\nsns.set_theme(style=\"whitegrid\")\n\n# 1. Generate synthetic data\nnp.random.seed(42)\nX_normal = 0.3 * np.random.randn(100, 2)\nX_normal = np.r_[X_normal + 2, X_normal - 2]\n\n# Add outliers\nX_outliers = np.random.uniform(low=-4, high=4, size=(20, 2))\nX = np.r_[X_normal, X_outliers]\n\n# 2. Train Isolation Forest model\nclf = IsolationForest(contamination=0.1, random_state=42)\npreds = clf.fit_predict(X)\n\n# 3. Prepare results\ndf = pd.DataFrame(X, columns=['Feature 1', 'Feature 2'])\ndf['Result'] = np.where(preds == 1, 'Normal', 'Anomaly')\n\nprint(f\"Total points: {len(df)}\")\nprint(f\"Anomalies detected: {len(df[df['Result'] == 'Anomaly'])}\")\n\n# 4. Visualization with Seaborn\nplt.figure(figsize=(10, 6))\nsns.scatterplot(data=df, x='Feature 1', y='Feature 2', \n                hue='Result', style='Result', \n                palette={'Normal': 'skyblue', 'Anomaly': 'red'},\n                s=100, edgecolor='black')\n\nplt.title(\"Anomaly Detection (Isolation Forest + Seaborn)\")\nplt.show()</textarea>\n    </div>\n    <div class=\"ds-editor-footer\">\n      <span>Press Ctrl+Enter to run</span>\n    </div>\n  </div>\n\n  <button id=\"btn-execute\" class=\"ds-btn-execute\">\n    <svg viewBox=\"0 0 24 24\" width=\"14\" height=\"14\" fill=\"currentColor\"><polygon points=\"5 3 19 12 5 21 5 3\"></polygon></svg>\n    Execute\n  </button>\n\n  <div id=\"results-section\" class=\"ds-results-container\" style=\"display: none;\">\n    <div class=\"ds-results-header\">\n      <div class=\"ds-results-icon\">\n        <div style=\"background: #4285f4;\"></div>\n        <div style=\"background: #ea4335;\"></div>\n        <div style=\"background: #fbbc05;\"></div>\n        <div style=\"background: #34a853;\"></div>\n      </div>\n      RESULTS\n    </div>\n    <div class=\"ds-results-content\">\n      <div id=\"output-text\" class=\"ds-output-text\"></div>\n      <div id=\"output-plot\" class=\"ds-output-plot\"></div>\n    </div>\n  </div>\n\n  <div id=\"loader\" class=\"ds-loader\" style=\"display: none;\">\n    <div class=\"ds-spinner\"></div>\n    <span id=\"loader-text\">Loading Python...</span>\n  </div>\n</div>",
    "css": ":host {\n  --ds-bg: #1a1a1a;\n  --ds-card-bg: #242424;\n  --ds-accent: #2ecc71;\n  --ds-text: #888888;\n  --ds-text-bright: #dddddd;\n  --ds-border: #333333;\n  --ds-font-code: 'Fira Code', 'Cascadia Code', Consolas, monospace;\n}\n\n.ds-container {\n  font-family: var(--font-interface);\n  background: var(--ds-bg);\n  border-radius: 8px;\n  padding: 16px;\n  display: flex;\n  flex-direction: column;\n  gap: 12px;\n  color: var(--ds-text-bright);\n}\n\n.ds-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 4px;\n}\n\n.ds-title-wrap {\n  display: flex;\n  align-items: center;\n  gap: 10px;\n}\n\n.ds-logo {\n  color: var(--ds-accent);\n  display: flex;\n  align-items: center;\n}\n\n.ds-title-text {\n  display: flex;\n  flex-direction: column;\n  line-height: 1.1;\n}\n\n.ds-main-title {\n  font-size: 12px;\n  font-weight: 700;\n  letter-spacing: 0.5px;\n  color: #aaa;\n}\n\n.ds-sub-title {\n  font-size: 9px;\n  font-weight: 600;\n  color: #666;\n}\n\n.ds-top-actions {\n  display: flex;\n  gap: 8px;\n}\n\n.ds-btn-tool {\n  background: #333;\n  border: none;\n  color: #aaa;\n  padding: 4px 10px;\n  border-radius: 4px;\n  font-size: 11px;\n  display: flex;\n  align-items: center;\n  gap: 6px;\n  cursor: pointer;\n  transition: all 0.2s;\n}\n\n.ds-btn-tool:hover {\n  background: #444;\n  color: #fff;\n}\n\n.ds-editor-card {\n  background: var(--ds-card-bg);\n  border: 1px solid var(--ds-border);\n  border-radius: 6px;\n  padding: 12px;\n  display: flex;\n  flex-direction: column;\n}\n\n.ds-editor-wrapper {\n  position: relative;\n  width: 100%;\n  height: 250px;\n  min-height: 100px;\n  resize: vertical;\n  overflow: hidden;\n  background: #1e1e1e;\n  border-radius: 4px;\n}\n\n#code-editor, #highlighting {\n  margin: 0;\n  padding: 10px;\n  padding-bottom: 30px; /* Space for footer and last line */\n  border: 0;\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  top: 0;\n  left: 0;\n  font-family: var(--ds-font-code);\n  font-size: 13px;\n  line-height: 1.5;\n  tab-size: 4;\n  white-space: pre;\n  word-wrap: normal;\n  overflow: auto;\n  box-sizing: border-box;\n}\n\n#code-editor {\n  z-index: 1;\n  white-space: pre;\n  color: transparent;\n  background: transparent;\n  caret-color: white;\n  resize: none;\n  outline: none;\n}\n\n#highlighting {\n  z-index: 0;\n  pointer-events: none;\n}\n\n.ds-editor-footer {\n  display: flex;\n  justify-content: flex-end;\n  padding-top: 6px;\n  font-size: 10px;\n  color: #555;\n}\n\n/* Prism Theme Overrides */\n.token.comment { color: #6a9955; }\n.token.keyword { color: #569cd6; }\n.token.string { color: #ce9178; }\n.token.function { color: #dcdcaa; }\n.token.number { color: #b5cea8; }\n.token.operator { color: #d4d4d4; }\n.token.class-name { color: #4ec9b0; }\n.token.builtin { color: #4fc1ff; }\n.token.property { color: #9cdcfe; }\n\n.ds-btn-execute {\n  background: #333;\n  border: none;\n  color: #eee;\n  padding: 8px;\n  border-radius: 6px;\n  font-size: 13px;\n  font-weight: 600;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: 8px;\n  cursor: pointer;\n  transition: background 0.2s;\n}\n\n.ds-btn-execute:hover {\n  background: #444;\n}\n\n.ds-results-container {\n  background: #000;\n  border-left: 3px solid var(--ds-accent);\n  border-radius: 2px;\n  margin-top: 4px;\n  transition: opacity 0.3s;\n}\n\n.ds-results-container.ds-loading {\n  opacity: 0.4;\n  pointer-events: none;\n}\n\n.ds-results-header {\n  padding: 8px 12px;\n  font-size: 10px;\n  font-weight: 700;\n  color: #888;\n  display: flex;\n  align-items: center;\n  gap: 10px;\n  border-bottom: 1px solid #111;\n}\n\n.ds-results-icon {\n  display: grid;\n  grid-template-columns: 1fr 1fr;\n  gap: 1px;\n  width: 10px;\n  height: 10px;\n}\n\n.ds-results-icon div {\n  width: 4px;\n  height: 4px;\n}\n\n.ds-results-content {\n  padding: 12px;\n  min-height: 40px;\n}\n\n.ds-output-text {\n  font-family: var(--ds-font-code);\n  font-size: 12px;\n  color: #aaa;\n  white-space: pre-wrap;\n}\n\n.ds-output-plot {\n  display: flex;\n  justify-content: center;\n  background: white;\n  padding: 10px;\n  border-radius: 4px;\n  margin-top: 10px;\n}\n\n.ds-output-plot img {\n  max-width: 100%;\n  height: auto;\n}\n\n.ds-loader {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: 12px;\n  padding: 10px;\n}\n\n.ds-spinner {\n  width: 16px;\n  height: 16px;\n  border: 2px solid var(--ds-accent);\n  border-top-color: transparent;\n  border-radius: 50%;\n  animation: spin 0.8s linear infinite;\n}\n\n@keyframes spin {\n  to { transform: rotate(360deg); }\n}\n\n#loader-text {\n  font-size: 11px;\n  color: #666;\n}\n\n/* ðŸ”§ FIX: caret / Prism alignment (hard lock metrics) */\n#code-editor,\n#highlighting,\n#highlighting-content,\n#highlighting-content * {\n  font-family: var(--ds-font-code) !important;\n  font-size: 13px !important;\n  line-height: 1.5 !important;\n  font-weight: 400 !important;\n  letter-spacing: 0 !important;\n  word-spacing: 0 !important;\n  font-kerning: none !important;\n  font-synthesis: none !important;\n  font-variant-ligatures: none !important;\n  font-feature-settings: \"liga\" 0, \"calt\" 0, \"clig\" 0, \"dlig\" 0, \"hlig\" 0 !important;\n}\n\n#highlighting-content {\n  display: block;\n  white-space: pre;\n  tab-size: 4;\n}\n",
    "js": "let pyodide = null;\nconst PYODIDE_VERSION = 'v0.23.4';\nconst PYODIDE_BASE = `https://cdn.jsdelivr.net/pyodide/${PYODIDE_VERSION}/full/`;\nconst PRISM_JS = 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js';\nconst PRISM_PYTHON = 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js';\n\nasync function init() {\n  const editorWrapper = api.root.querySelector('.ds-editor-wrapper');\n  const editor = api.root.querySelector('#code-editor');\n  const highlightContent = api.root.querySelector('#highlighting-content');\n  const highlightPre = api.root.querySelector('#highlighting');\n  const btnExecute = api.root.querySelector('#btn-execute');\n  const btnClear = api.root.querySelector('#btn-clear');\n  const btnCopy = api.root.querySelector('#btn-copy');\n  const resultsSection = api.root.querySelector('#results-section');\n  const outputText = api.root.querySelector('#output-text');\n  const outputPlot = api.root.querySelector('#output-plot');\n  const loader = api.root.querySelector('#loader');\n  const loaderText = api.root.querySelector('#loader-text');\n\n  // Load Prism\n  await loadScriptOnce(PRISM_JS);\n  await loadScriptOnce(PRISM_PYTHON);\n\n  // Helper: merge-save state (so we can add editorHeight without wiping other fields)\n  const saveStatePartial = async (partial) => {\n    try {\n      const currentState = await api.getState();\n      const newState = Object.assign({}, currentState || {}, partial);\n      await api.saveState(newState);\n    } catch (e) {\n      console.error('Save state error:', e);\n    }\n  };\n\n  const updateHighlighting = () => {\n    let code = editor.value;\n    if (code[code.length - 1] === \"\\n\") code += \" \";\n    highlightContent.textContent = code;\n    if (window.Prism) window.Prism.highlightElement(highlightContent);\n  };\n\n  // Sync scrolling\n  editor.onscroll = () => {\n    highlightPre.scrollTop = editor.scrollTop;\n    highlightPre.scrollLeft = editor.scrollLeft;\n  };\n\n  editor.oninput = () => {\n    updateHighlighting();\n  };\n\n  // Restore state (code/output/plot + editor height)\n  let isInitializing = true;\n  const state = await api.getState?.();\n  if (state?.editorHeight && editorWrapper) {\n    editorWrapper.style.height = String(state.editorHeight) + 'px';\n  }\n\n  if (state?.code) {\n    editor.value = state.code;\n    updateHighlighting();\n  }\n\n  if (state?.lastOutput || state?.lastPlot) {\n    if (state.lastOutput) {\n      outputText.innerText = state.lastOutput;\n      outputText.style.display = 'block';\n    }\n    if (state.lastPlot) {\n      const img = document.createElement('img');\n      img.src = state.lastPlot;\n      outputPlot.innerHTML = '';\n      outputPlot.appendChild(img);\n      outputPlot.style.display = 'flex';\n    }\n    resultsSection.style.display = 'block';\n  }\n\n  // Persist editor resize (wrapper is resizable)\n  if (editorWrapper && typeof ResizeObserver !== 'undefined') {\n    let resizeT = null;\n    const ro = new ResizeObserver(() => {\n      if (isInitializing) return;\n      clearTimeout(resizeT);\n      resizeT = setTimeout(async () => {\n        const rect = editorWrapper.getBoundingClientRect();\n        const h = Math.round(rect.height);\n        if (h > 0 && (!state || state.editorHeight !== h)) {\n          await saveStatePartial({ editorHeight: h });\n        }\n      }, 500);\n    });\n    ro.observe(editorWrapper);\n  } else if (editorWrapper) {\n    // Fallback: save on pointerup/mouseup\n    const saveHeight = () => {\n      const h = Math.max(100, Math.round(editorWrapper.getBoundingClientRect().height));\n      saveStatePartial({ editorHeight: h });\n    };\n    editorWrapper.addEventListener('pointerup', saveHeight);\n    editorWrapper.addEventListener('mouseup', saveHeight);\n    editorWrapper.addEventListener('touchend', saveHeight);\n  }\n\n  // Allow ResizeObserver to start saving after a short delay\n  setTimeout(() => { isInitializing = false; }, 1000);\n\n  // Editing helpers\n  const INDENT = '    '; // 4 spaces\n\n  const getLineStart = (text, index) => {\n    const i = text.lastIndexOf('\\n', index - 1);\n    return i === -1 ? 0 : i + 1;\n  };\n\n  const getLineEnd = (text, index) => {\n    const i = text.indexOf('\\n', index);\n    return i === -1 ? text.length : i;\n  };\n\n  const getSelectedLineRange = (text, selStart, selEnd) => {\n    const startLineStart = getLineStart(text, selStart);\n    // if selection ends exactly at line start of next line, keep previous line\n    const adjustedEnd = selEnd > 0 && text[selEnd - 1] === '\\n' ? selEnd - 1 : selEnd;\n    const endLineEnd = getLineEnd(text, adjustedEnd);\n    return { start: startLineStart, end: endLineEnd };\n  };\n\n  const indentSelection = () => {\n    const text = editor.value;\n    const selStart = editor.selectionStart;\n    const selEnd = editor.selectionEnd;\n    const range = getSelectedLineRange(text, selStart, selEnd);\n    const before = text.slice(0, range.start);\n    const block = text.slice(range.start, range.end);\n    const after = text.slice(range.end);\n\n    const lines = block.split('\\n');\n    const indented = lines.map(l => INDENT + l).join('\\n');\n\n    editor.value = before + indented + after;\n\n    // Selection adjustment\n    const addedPerLine = INDENT.length;\n    const lineCount = lines.length;\n    const newSelStart = selStart + (selStart >= range.start ? addedPerLine : 0);\n    const newSelEnd = selEnd + addedPerLine * lineCount;\n\n    editor.selectionStart = newSelStart;\n    editor.selectionEnd = newSelEnd;\n    updateHighlighting();\n  };\n\n  const unindentSelection = () => {\n    const text = editor.value;\n    let selStart = editor.selectionStart;\n    let selEnd = editor.selectionEnd;\n\n    const range = getSelectedLineRange(text, selStart, selEnd);\n    const before = text.slice(0, range.start);\n    const block = text.slice(range.start, range.end);\n    const after = text.slice(range.end);\n\n    const lines = block.split('\\n');\n    let removedTotal = 0;\n    let removedBeforeSelStart = 0;\n    let removedBeforeSelEnd = 0;\n\n    // Compute line starts relative to block to adjust selection accurately\n    let cursor = 0;\n    const relSelStart = selStart - range.start;\n    const relSelEnd = selEnd - range.start;\n\n    const newLines = lines.map((line) => {\n      let removed = 0;\n      if (line.startsWith(INDENT)) {\n        removed = INDENT.length;\n        line = line.slice(INDENT.length);\n      } else if (line.startsWith('\\t')) {\n        removed = 1;\n        line = line.slice(1);\n      } else {\n        // remove up to 4 leading spaces\n        const m = line.match(/^ {1,4}/);\n        if (m) {\n          removed = m[0].length;\n          line = line.slice(removed);\n        }\n      }\n\n      // selection shift accounting\n      const lineStartRel = cursor;\n      const lineEndRel = cursor + line.length + removed; // + removed because original line had them\n\n      // if selection start is on/after this line start, it may shift\n      if (relSelStart >= lineStartRel) {\n        // if caret is within this line's original indent region, clamp shift\n        const withinIndent = relSelStart < lineStartRel + removed;\n        removedBeforeSelStart += withinIndent ? (relSelStart - lineStartRel) : removed;\n      }\n      if (relSelEnd >= lineStartRel) {\n        const withinIndentEnd = relSelEnd < lineStartRel + removed;\n        removedBeforeSelEnd += withinIndentEnd ? (relSelEnd - lineStartRel) : removed;\n      }\n\n      removedTotal += removed;\n      cursor += (line.length + removed) + 1; // +1 for newline in split representation\n      return line;\n    });\n\n    const unindented = newLines.join('\\n');\n    editor.value = before + unindented + after;\n\n    // Restore selection\n    const newStart = Math.max(range.start, selStart - removedBeforeSelStart);\n    const newEnd = Math.max(newStart, selEnd - removedBeforeSelEnd);\n    editor.selectionStart = newStart;\n    editor.selectionEnd = newEnd;\n\n    updateHighlighting();\n  };\n\n  const commentSelection = () => {\n    const text = editor.value;\n    const selStart = editor.selectionStart;\n    const selEnd = editor.selectionEnd;\n    const range = getSelectedLineRange(text, selStart, selEnd);\n\n    const before = text.slice(0, range.start);\n    const block = text.slice(range.start, range.end);\n    const after = text.slice(range.end);\n\n    const lines = block.split('\\n');\n    const commented = lines.map(l => '# ' + l).join('\\n');\n\n    editor.value = before + commented + after;\n\n    // Adjust selection: add 2 chars per line\n    const added = 2;\n    const newSelStart = selStart + (selStart >= range.start ? added : 0);\n    const newSelEnd = selEnd + added * lines.length;\n    editor.selectionStart = newSelStart;\n    editor.selectionEnd = newSelEnd;\n\n    updateHighlighting();\n  };\n\n  const uncommentSelection = () => {\n    const text = editor.value;\n    let selStart = editor.selectionStart;\n    let selEnd = editor.selectionEnd;\n    const range = getSelectedLineRange(text, selStart, selEnd);\n\n    const before = text.slice(0, range.start);\n    const block = text.slice(range.start, range.end);\n    const after = text.slice(range.end);\n\n    const lines = block.split('\\n');\n    let removedBeforeSelStart = 0;\n    let removedBeforeSelEnd = 0;\n\n    let cursor = 0;\n    const relSelStart = selStart - range.start;\n    const relSelEnd = selEnd - range.start;\n\n    const newLines = lines.map((line) => {\n      const m = line.match(/^(\\s*)(#\\s?)/);\n      let removed = 0;\n      if (m) {\n        removed = m[2].length;\n        line = m[1] + line.slice(m[1].length + removed);\n      }\n\n      const lineStartRel = cursor;\n      if (relSelStart >= lineStartRel && removed > 0) {\n        const indentLen = m ? m[1].length : 0;\n        const hashStart = lineStartRel + indentLen;\n        const within = relSelStart < hashStart + removed;\n        removedBeforeSelStart += within ? Math.max(0, relSelStart - hashStart) : removed;\n      }\n      if (relSelEnd >= lineStartRel && removed > 0) {\n        const indentLen = m ? m[1].length : 0;\n        const hashStart = lineStartRel + indentLen;\n        const withinEnd = relSelEnd < hashStart + removed;\n        removedBeforeSelEnd += withinEnd ? Math.max(0, relSelEnd - hashStart) : removed;\n      }\n\n      cursor += (line.length + removed) + 1;\n      return line;\n    });\n\n    const newBlock = newLines.join('\\n');\n    editor.value = before + newBlock + after;\n\n    const newStart = Math.max(range.start, selStart - removedBeforeSelStart);\n    const newEnd = Math.max(newStart, selEnd - removedBeforeSelEnd);\n    editor.selectionStart = newStart;\n    editor.selectionEnd = newEnd;\n\n    updateHighlighting();\n  };\n\n  // Ctrl+K chord handling (K then C/U)\n  let ctrlKPending = false;\n  let ctrlKTimer = null;\n  const resetCtrlK = () => {\n    ctrlKPending = false;\n    if (ctrlKTimer) clearTimeout(ctrlKTimer);\n    ctrlKTimer = null;\n  };\n\n  // Handle Keys\n  editor.onkeydown = (e) => {\n    const isCmd = e.metaKey;\n    const isCtrl = e.ctrlKey;\n    const mod = isCmd || isCtrl;\n\n    // Handle Ctrl/Cmd+K (start chord)\n    if (mod && !e.shiftKey && !e.altKey && e.key.toLowerCase() === 'k') {\n      e.preventDefault();\n      ctrlKPending = true;\n      if (ctrlKTimer) clearTimeout(ctrlKTimer);\n      ctrlKTimer = setTimeout(resetCtrlK, 1000);\n      return;\n    }\n\n    // Handle chord second key\n    if (ctrlKPending && !mod && !e.shiftKey && !e.altKey) {\n      const k = e.key.toLowerCase();\n      if (k === 'c') {\n        e.preventDefault();\n        commentSelection();\n        resetCtrlK();\n        return;\n      }\n      if (k === 'u') {\n        e.preventDefault();\n        uncommentSelection();\n        resetCtrlK();\n        return;\n      }\n      // any other key cancels chord\n      resetCtrlK();\n    }\n\n    // Tab / Shift+Tab\n    if (e.key === 'Tab') {\n      e.preventDefault();\n      if (e.shiftKey) {\n        unindentSelection();\n      } else {\n        // If selection is collapsed, keep original behavior (insert 4 spaces)\n        const start = editor.selectionStart;\n        const end = editor.selectionEnd;\n        if (start === end) {\n          editor.value = editor.value.substring(0, start) + INDENT + editor.value.substring(end);\n          editor.selectionStart = editor.selectionEnd = start + INDENT.length;\n          updateHighlighting();\n        } else {\n          indentSelection();\n        }\n      }\n      return;\n    }\n\n    // Ctrl+Enter to run\n    if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {\n      e.preventDefault();\n      btnExecute.click();\n      return;\n    }\n  };\n\n  btnExecute.onclick = async () => {\n    if (btnExecute.disabled) return;\n\n    btnExecute.disabled = true;\n    loader.style.display = 'flex';\n    resultsSection.classList.add('ds-loading');\n\n    try {\n      if (!pyodide) {\n        loaderText.innerText = 'Loading Python & DS Libraries...';\n        await ensureBrowserPyodideLoader();\n        pyodide = await createPyodideInstance();\n        // ICI: Ajout de l'API ObsidGet dans Python\n        try { pyodide.registerJsModule(\"obsidget_api\", api); } catch (e) {}\n      }\n\n      loaderText.innerText = 'Executing...';\n\n      let stdout = '';\n      let stderr = '';\n      pyodide.setStdout({ batched: (str) => { stdout += str + '\\n'; } });\n      pyodide.setStderr({ batched: (str) => { stderr += str + '\\n'; } });\n\n      const code = editor.value;\n\n      // FIX BACKEND AGG: On ajoute le switch_backend('Agg') avant tout le reste\n      const runCode = \"import io, base64, sys\\nimport matplotlib\\nmatplotlib.use('Agg')\\nimport matplotlib.pyplot as plt\\nimport numpy as np\\nimport pandas as pd\\nimport micropip\\n\\n# Force backend non-interactif\\nplt.switch_backend('Agg')\\n\\ndef custom_show():\\n    fig = plt.gcf()\\n    if fig.get_axes():\\n        buf = io.BytesIO()\\n        plt.savefig(buf, format='png', dpi=100, bbox_inches='tight', facecolor='white')\\n        buf.seek(0)\\n        img_base64 = base64.b64encode(buf.read()).decode('UTF-8')\\n        print(f'__PLOT_DATA__:{img_base64}')\\n    plt.close('all')\\n\\nplt.show = custom_show\\nplt.close('all')\\n\\n\" + code + \"\\n\\ncustom_show()\";\n\n      await pyodide.runPythonAsync(runCode);\n\n      const plotMatch = stdout.match(/__PLOT_DATA__:([A-Za-z0-9+/=]+)/);\n      const cleanStdout = stdout.replace(/__PLOT_DATA__:[A-Za-z0-9+/=]+\\n?/, '').trim();\n\n      let lastPlot = null;\n      if (plotMatch) {\n        lastPlot = 'data:image/png;base64,' + plotMatch[1];\n        const img = document.createElement('img');\n        img.src = lastPlot;\n        outputPlot.innerHTML = '';\n        outputPlot.appendChild(img);\n        outputPlot.style.display = 'flex';\n      } else {\n        outputPlot.innerHTML = '';\n        outputPlot.style.display = 'none';\n      }\n\n      const lastOutput = cleanStdout + (stderr ? '\\n[stderr]\\n' + stderr : '');\n      if (lastOutput) {\n        outputText.innerText = lastOutput;\n        outputText.style.display = 'block';\n      } else {\n        outputText.innerText = '';\n        outputText.style.display = 'none';\n      }\n\n      resultsSection.style.display = 'block';\n      resultsSection.classList.remove('ds-loading');\n\n      await saveStatePartial({ code, lastOutput, lastPlot });\n\n    } catch (err) {\n      console.error('Pyodide Error:', err);\n      outputText.innerHTML = `<span style=\"color: #e74c3c\">Error: ${err?.message || String(err)}</span>`;\n      outputText.style.display = 'block';\n      resultsSection.style.display = 'block';\n      resultsSection.classList.remove('ds-loading');\n    } finally {\n      loader.style.display = 'none';\n      btnExecute.disabled = false;\n    }\n  };\n\n  btnClear.onclick = async () => {\n    editor.value = '';\n    updateHighlighting();\n    resultsSection.style.display = 'none';\n    await saveStatePartial({ code: '', lastOutput: null, lastPlot: null });\n  };\n\n  btnCopy.onclick = () => {\n    navigator.clipboard.writeText(editor.value);\n    try { new Notice('Code copied!'); } catch (e) {}\n  };\n\n  updateHighlighting();\n}\n\nfunction loadScriptOnce(url) {\n  return new Promise((resolve, reject) => {\n    const existing = document.querySelector(\"script[data-src='\" + url + \"']\");\n    if (existing) return resolve();\n    const script = document.createElement('script');\n    script.src = url;\n    script.async = true;\n    script.dataset.src = url;\n    script.onload = resolve;\n    script.onerror = () => reject(new Error('Failed to load script: ' + url));\n    document.head.appendChild(script);\n  });\n}\n\nasync function withNodeGlobalsHidden(fn) {\n  const g = globalThis;\n  const keys = ['process', 'require', 'module', 'exports', 'Buffer', 'global'];\n  const saved = {};\n  for (const k of keys) {\n    if (k in g) saved[k] = g[k];\n    try { g[k] = undefined; delete g[k]; } catch (e) {}\n  }\n  try { return await fn(); } finally {\n    for (const k of keys) { if (k in saved) g[k] = saved[k]; }\n  }\n}\n\nasync function ensureBrowserPyodideLoader() {\n  if (window.__PYODIDE_BROWSER_LOADER_READY__) return;\n  try { delete window.loadPyodide; } catch (e) {}\n  await withNodeGlobalsHidden(async () => {\n    await loadScriptOnce(PYODIDE_BASE + 'pyodide.js');\n    if (typeof window.loadPyodide !== 'function') throw new Error('Pyodide loader not found.');\n    window.__PYODIDE_BROWSER_LOADER_READY__ = true;\n  });\n}\n\nasync function createPyodideInstance() {\n  return await withNodeGlobalsHidden(async () => {\n    const instance = await window.loadPyodide({ indexURL: PYODIDE_BASE });\n    await instance.loadPackage(['numpy', 'matplotlib', 'pandas', 'scikit-learn', 'scipy', 'sympy', 'micropip']);\n    await instance.runPythonAsync('import micropip; await micropip.install(\"seaborn\")');\n    return instance;\n  });\n}\n\ninit();"
}